#!/usr/bin/env php
<?php

declare(strict_types=1);

use Koriym\AppStateDiagram\ConfigFactory;
use Koriym\AppStateDiagram\Diagram;
use Koriym\AppStateDiagram\Exception\AlpsFileNotReadableException;
use Koriym\AppStateDiagram\PutDiagram;
use Koriym\DataFile\Exception\DataFileNotFoundException;

foreach ([__DIR__ . '/../../../autoload.php', __DIR__ . '/../vendor/autoload.php'] as $file) {
    if (file_exists($file)) {
        require $file;

        break;
    }
}
if ($argc === 1) {
    echo <<<EOT
usage: asd [options] alps_file

Options:
  -c, --config <path>     Use custom config file
  -e, --echo              Output to stdout instead of file
  -w, --watch             Watch mode with live reload
  -m, --mode <mode>       Output mode (html|markdown|svg)
  --port <port>           Port for watch mode (default: 3000)
  -v, --version           Show version information
  -h, --help              Show this help message

@see https://github.com/alps-asd/app-state-diagram#usage

EOT;
    exit(0);
}
$options = getopt('c:e::w::m::v', ['config:', 'echo::', 'watch::', 'mode::', 'port::', 'version']);
// Handle --version option
if (isset($options['v']) || isset($options['version'])) {
    $pharRunning = Phar::running(false);
    
    if ($pharRunning !== '') {
        // Try to extract version from Homebrew Cellar path
        if (preg_match('#/Cellar/asd/([^/]+)/#', $pharRunning, $matches)) {
            echo "asd version {$matches[1]} (Homebrew)\n";
        } else {
            echo "asd (PHAR version - version info not available)\n";
        }
    } else {
        echo "asd (development version - version info not available)\n";
    }
    exit(0);
}

if ($argc === 1) {
    $options['c'] = getcwd();
}
try {
    $configOption = $options['c'] ?? $options['config'] ?? null;
    $config = $configOption !== null ? ConfigFactory::fromFile($configOption, $argc, $argv, $options) : ConfigFactory::fromCommandLine($argc, $argv, $options);
} catch (DataFileNotFoundException $e) {
    printf('Config file not found: %s', $e->getMessage());
    exit(1);
} catch (AlpsFileNotReadableException $e) {
    printf('Profile file not found: %s', $e->getMessage());
    exit(1);
}
if ($config->watch) {
    $pharRunning = Phar::running(false);
    $actualPath = dirname(__DIR__) . '/asd-sync';
    
    if ($pharRunning !== '') {
        // PHAR execution: use version-independent opt path for better compatibility
        // PHAR path: "/opt/homebrew/Cellar/asd/x.x.x/libexec/asd.phar"
        // Target:    "/opt/homebrew/opt/asd/libexec/asd-sync" (version-independent)
        $pharDir = dirname($pharRunning);
        $actualPath = $pharDir . '/asd-sync';
        
        // Try version-independent opt path if not found in Cellar
        if (!is_dir($actualPath)) {
            $homebrewPrefix = trim(shell_exec('brew --prefix 2>/dev/null') ?? '');
            if ($homebrewPrefix !== '') {
                $optPath = $homebrewPrefix . '/opt/asd/libexec/asd-sync';
                if (is_dir($optPath)) {
                    $actualPath = $optPath;
                }
            }
        }
    }
    
    if (!is_dir($actualPath)) {
        echo "Error: asd-sync directory not found. Watch mode requires Node.js components.\n";
        echo "Expected path: $actualPath\n";
        exit(1);
    }
    
    chdir($actualPath);
    $nodeModulesPath = $actualPath . '/node_modules';
    $isFirstRun = !is_dir($nodeModulesPath);
    if ($isFirstRun) {
        echo "Installing Node.js dependencies...\n";
        passthru('npm install');
    }

    passthru("npm start -- --profile {$config->profile} --port {$config->port}");
    exit(0);
}

try {
    $index = (new Diagram())($config);
    $isEcho =  (isset($options['e']) || isset($options['echo']));
    if ($isEcho) {
        echo $index->content;
        exit;
    }
    // Don't generate HTML file for SVG mode
    if ($config->outputMode !== 'svg') {
        file_put_contents($index->file, $index->content);
        echo "ASD generated. {$index->file}" . PHP_EOL;
    }
} catch (Exception $e) {
    $shortName = (new \ReflectionClass($e))->getShortName();
    $msg = sprintf("asd: %s(%s)",$shortName, $e->getMessage());
    file_put_contents('php://stderr', $msg . PHP_EOL);
    exit(1);
}
